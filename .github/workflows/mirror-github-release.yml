name: Mirror repos + releases (full)

on:
  workflow_dispatch:
  schedule:
    - cron: "21 19 * * *"  # UTC 02:41 (JST 11:41)

permissions:
  contents: write

concurrency:
  group: mirror-with-releases-full
  cancel-in-progress: false

jobs:
  mirror:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          # ====== 把你要同步的 repo 都放这里 ======
          - { src: "https://github.com/sbwml/openwrt-llvm-toolchain", dst: "openwrt-llvm-toolchain" }
          - { src: "https://github.com/sbwml/openwrt_caches",              dst: "openwrt_caches" }
          # =======================================

    steps:
      - name: Mirror repo + releases/assets
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          DST_OWNER: xianren78   # TODO: 改成你的 GitHub 用户名或组织名
          SRC_URL: ${{ matrix.src }}
          DST_REPO: ${{ matrix.dst }}
        run: |
          set -euo pipefail
          [ -n "${GH_PAT}" ] || (echo "GH_PAT is empty (missing Actions secret?)"; exit 1)

          echo "==> SRC: ${SRC_URL}"
          echo "==> DST: ${DST_OWNER}/${DST_REPO}"

          API="https://api.github.com"
          AUTH="Authorization: token ${GH_PAT}"

          # -------- 解析源仓库 owner/repo --------
          SRC_PATH="${SRC_URL#https://github.com/}"
          SRC_PATH="${SRC_PATH%.git}"
          SRC_OWNER="${SRC_PATH%%/*}"
          SRC_REPO="${SRC_PATH#*/}"
          echo "==> SRC_OWNER=${SRC_OWNER} SRC_REPO=${SRC_REPO}"

          # 目标 push URL
          dst_url="https://x-access-token:${GH_PAT}@github.com/${DST_OWNER}/${DST_REPO}.git"

          # -------- 1) 创建目标仓库（不存在才创建）--------
          if curl -fsSL -H "${AUTH}" "${API}/orgs/${DST_OWNER}" >/dev/null 2>&1; then
            CREATE_URL="${API}/orgs/${DST_OWNER}/repos"
            CREATE_BODY=$(jq -nc --arg name "${DST_REPO}" '{name:$name, private:false}')
          else
            CREATE_URL="${API}/user/repos"
            CREATE_BODY=$(jq -nc --arg name "${DST_REPO}" '{name:$name, private:false}')
          fi

          if curl -fsSL -H "${AUTH}" "${API}/repos/${DST_OWNER}/${DST_REPO}" >/dev/null 2>&1; then
            echo "Repo exists: ${DST_OWNER}/${DST_REPO}"
          else
            echo "Creating repo: ${DST_OWNER}/${DST_REPO}"
            curl -fsSL -X POST -H "${AUTH}" -H "Content-Type: application/json" \
              -d "${CREATE_BODY}" "${CREATE_URL}" >/dev/null
          fi

          # -------- 2) 同步分支 + tags（排除 refs/pull/*）--------
          work="$(mktemp -d)"
          trap 'rm -rf "$work"' EXIT

          repo_dir="${work}/repo.git"
          rm -rf "${repo_dir}"

          git config --global --unset-all http.https://github.com/.extraheader || true
          git config --global credential.helper ""
          git config --global user.email "actions@github.com"
          git config --global user.name  "github-actions[bot]"

          git clone --mirror "${SRC_URL}" "${repo_dir}"
          cd "${repo_dir}"

          git for-each-ref --format='%(refname)' refs/pull | xargs -r -n1 git update-ref -d
          git push --force --prune "${dst_url}" "refs/heads/*:refs/heads/*"
          git push --force --prune "${dst_url}" "refs/tags/*:refs/tags/*"
          echo "==> Git refs synced."

          # -------- 3) 同步 Releases + assets（保持源文件名；分页查 assets）--------
          export GH_TOKEN="${GH_PAT}"

          # 拉取源 releases（前 100 个，够用不够再加分页）
          src_releases="$(curl -fsSL -H "Accept: application/vnd.github+json" \
            "${API}/repos/${SRC_OWNER}/${SRC_REPO}/releases?per_page=100")"
          rel_count="$(echo "${src_releases}" | jq 'length')"
          echo "==> Source releases: ${rel_count}"
          [ "${rel_count}" -eq 0 ] && exit 0

          assets_dir="${work}/assets"
          mkdir -p "${assets_dir}"

          # helper：获取目标 release_id（通过 tag）
          get_dst_release_id() {
            local tag="$1"
            gh api -H "Accept: application/vnd.github+json" \
              "/repos/${DST_OWNER}/${DST_REPO}/releases/tags/${tag}" \
              --jq '.id' 2>/dev/null || true
          }

          # helper：分页拉取目标 release 的所有 asset 名称
          # 输出：每行一个 asset name
          list_dst_asset_names() {
            local release_id="$1"
            gh api --paginate -H "Accept: application/vnd.github+json" \
              "/repos/${DST_OWNER}/${DST_REPO}/releases/${release_id}/assets?per_page=100" \
              --jq '.[].name' 2>/dev/null || true
          }

          echo "${src_releases}" | jq -c '.[]' | while read -r rel; do
            tag="$(echo "${rel}" | jq -r '.tag_name')"
            name="$(echo "${rel}" | jq -r '.name // empty')"
            body="$(echo "${rel}" | jq -r '.body // empty')"
            draft="$(echo "${rel}" | jq -r '.draft')"
            prerelease="$(echo "${rel}" | jq -r '.prerelease')"
            target="$(echo "${rel}" | jq -r '.target_commitish // empty')"

            echo "---- Release tag: ${tag} target_commitish=${target:-<empty>}"

            # 3.1 创建目标 release（不存在才创建）
            if gh release view "${tag}" --repo "${DST_OWNER}/${DST_REPO}" >/dev/null 2>&1; then
              echo "Release exists on destination: ${tag}"
            else
              use_target=""
              if [ -n "${target}" ] && [ "${target}" != "null" ] && [ "${target}" != "HEAD" ]; then
                if git ls-remote --exit-code "${dst_url}" "refs/heads/${target}" >/dev/null 2>&1; then
                  use_target="${target}"
                elif git ls-remote --exit-code "${dst_url}" "refs/tags/${target}" >/dev/null 2>&1; then
                  use_target="${target}"
                fi
              fi

              echo "Creating release on destination: ${tag} (target=${use_target:-<default>})"
              args=( "${tag}" --repo "${DST_OWNER}/${DST_REPO}" )
              [ -n "${use_target}" ] && args+=( --target "${use_target}" )
              [ -n "${name}" ] && args+=( --title "${name}" )
              args+=( --notes "${body}" )
              [ "${prerelease}" = "true" ] && args+=( --prerelease )
              [ "${draft}" = "true" ] && args+=( --draft )
              gh release create "${args[@]}"
            fi

            # 3.2 关键：分页获取“目标 release 全量 assets 名称”，写入文件，供下载前判断
            dst_release_id="$(get_dst_release_id "${tag}")"
            if [ -z "${dst_release_id}" ]; then
              echo "  - warning: cannot get destination release id for tag=${tag}, skipping assets"
              continue
            fi

            dst_assets_file="${work}/dst_assets_${tag}.txt"
            list_dst_asset_names "${dst_release_id}" | sed 's/\r$//' > "${dst_assets_file}" || true

            echo "${rel}" | jq -c '.assets[]? // empty' | while read -r a; do
              aname="$(echo "${a}" | jq -r '.name')"
              adl="$(echo "${a}" | jq -r '.browser_download_url')"

              # 下载前判断：用“全量 assets 列表”匹配（不会漏页）
              if grep -Fxq "${aname}" "${dst_assets_file}"; then
                echo "  - asset exists, skip download: ${aname}"
                continue
              fi

              tmpfile="${assets_dir}/${aname}"
              rm -f "${tmpfile}"

              echo "  - downloading: ${aname}"
              curl -fL --retry 3 --retry-delay 2 -o "${tmpfile}" "${adl}"

              # 2GB 上限保护
              size="$(stat -c%s "${tmpfile}")"
              max=$((1900 * 1024 * 1024))
              if [ "${size}" -gt "${max}" ]; then
                echo "  - skip (too large > ~1.9GB): ${aname} (${size} bytes)"
                rm -f "${tmpfile}"
                continue
              fi

              # 兜底：下载后再查一次（重新分页拉一次或增量更新列表）
              # 这里增量更新：若有人并发上传，我们再查一遍当前列表
              if list_dst_asset_names "${dst_release_id}" | sed 's/\r$//' | grep -Fxq "${aname}"; then
                echo "  - asset appeared during download, skip upload: ${aname}"
                rm -f "${tmpfile}"
                continue
              fi

              echo "  - uploading: ${aname}"
              # asset 名 = 本地 basename = aname（保持源文件名）
              gh release upload "${tag}" "${tmpfile}" --repo "${DST_OWNER}/${DST_REPO}"
              # 若你想并发永不失败，改成：
              # gh release upload "${tag}" "${tmpfile}" --repo "${DST_OWNER}/${DST_REPO}" --clobber

              rm -f "${tmpfile}"
            done
          done

          echo "==> Releases/assets synced."
